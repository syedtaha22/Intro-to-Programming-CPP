/*
    Task 1:
        To better understand how memory allocation works in C++, we will explore
        the internal operations that occur during dynamic memory allocation and
        deallocation. Begin by adding the following overloaded functions to your
        program:

        ```
        void* operator new(const size_t size) {
            // Overloads the new operator to log the size of the memory being allocated
            std::cout << "Allocating " << size << " bytes" << std::endl;
            return malloc(size);
        }

        void operator delete(void* memory, std::size_t size) noexcept {
            // Overloads the delete operator to log the size of the memory being deallocated
            std::cout << "Deallocating " << size << " bytes" << std::endl;
            free(memory);
        }
        ```

        Next, implement two functions,
         i ) exploreVectorMemoryBehavior() and
         ii) exploreDynamicMemoryBehavior(),
        to systematically test memory allocation.

        In exploreVectorMemoryBehavior(), you will use a std::vector and experiment
        with the push_back operation. Focus on observing when memory is allocated
        and deallocated as elements are added. Add comments in your code to indicate
        where memory allocation occurs due to this operation.

        In exploreDynamicMemoryBehavior(), you will create and delete objects dynamically
        using new and delete. Test this with different types and sizes of objects,
        and observe the logs generated by the custom operator new and operator delete.
        Again, add comments on the lines where memory is allocated and deallocated.

        Finally, write detailed comments at the end of each function summarizing your
        observations.

*/

#include <iostream>
#include <vector>

// Overload the new operator to log memory allocation for single objects
void* operator new(const size_t size) {
    std::cout << "Allocating " << size << " bytes" << std::endl;
    return malloc(size);
}

// Overload the delete operator to log memory deallocation for single objects
void operator delete(void* memory, std::size_t size) noexcept {
    std::cout << "Deallocating " << size << " bytes" << std::endl;
    free(memory);
}

// Overload the new[] operator to log memory allocation for arrays
void* operator new[](const size_t size) {
    std::cout << "Allocating array of " << size << " bytes" << std::endl;
    return malloc(size);
}

// Overload the delete[] operator to log memory deallocation for arrays
void operator delete[](void* memory) noexcept {
    std::cout << "Deallocating array" << std::endl;
    free(memory);
}



void PushBackTest() {
    // No memory allocated for the vector yet
    std::vector<int> vec;

    // Pushing back 5 elements

    /*
        Currently the vector does not have capacity enough to hold
        an element, so when we push back a number, it will allocate
        memory for 1 element. i.e. 4 bytes (for int)
    */
    vec.push_back(1); // Memory allocated for 1 element (4 bytes)

    /*
        From previous push_back, the vector has capacity for 1 element,
        If we push back another element, it will need to allocate more memory
        for it, so it will double the capacity, i.e 2 * 4 bytes = 8 bytes will be
        allocated.
        The previous vector will be copied to the new memory location and the old
        memory will be deallocated. (Deallocating 4 bytes)
    */
    vec.push_back(2); // Memory Doubled, capacity for 2 elements (8 bytes)

    /*
        The vector now has capacity for 2 elements, if we push back another element,
        it will need to allocate more memory for it, so it will double the capacity,
        i.e 4 * 4 bytes = 16 bytes will be allocated.
        The previous vector will be copied to the new memory location and the old
        memory will be deallocated. (Deallocating 8 bytes)
    */
    vec.push_back(3); // Memory Doubled, capacity for 4 elements (16 bytes)

    /*
        The vector now has capacity for 4 (16 bytes = 4 ints) elements, if we push back
        another element, this time it has space for one more element, so it will not need
        to allocated more memory, it will just add the element to the existing memory.
        Hence nothing is printed.
    */
    vec.push_back(4); // No memory allocated

    /*
        The vector now has capacity for 4 elements, if we push back another element,
        it will need to allocate more memory for it, so it will double the capacity,
        i.e 8 * 4 bytes = 32 bytes will be allocated.
        The previous vector will be copied to the new memory location and the old
        memory will be deallocated. (Deallocating 16 bytes)
    */
    vec.push_back(5); // Memory Doubled, capacity for 8 elements (32 bytes)

    /*
        Function goes out of scope, so the memory allocated for the vector will be
        deallocated.
        (Deallocating 32 bytes)
    */
    return;
}

void DynamicMemoryTest() {
    /*
        Allocate memory for a double object (8 bytes)
        Memory allocated for 1 double (8 bytes)
    */
    double* d = new double;

    /*
        Create a dynamic array of 5 integers (20 bytes)
        Memory allocated for 5 ints (20 bytes)
    */
    int* intArr = new int[5];

    /*
        Declare variables normally
        Memory allocated at compile time. Nothing is printed.
    */
    int x = 5;
    double y = 3.14;
    std::string z = "Hello, World!";
    int arr[5] = { 1, 2, 3, 4, 5 };

    /*
        Allocate memory for a string object (32 bytes)
    */
    std::string* str = new std::string("Hello, World!");

    /*
        Deallocate memory for the double, and string objects
    */
    delete d; // Memory deallocated for 1 double (8 bytes)
    delete str; // Memory deallocated for 1 string (32 bytes)

    /*
        Dynamic Allocated Memory needs to be manually deleted.
        Since we won't call delete[] on intArr, it will not be deallocated.
    */
    return;
}
\
int main() {
    /*
        Summary of PushBackTest():
            - The vector initially has no memory allocated.
            - Memory is only allocated if the vector is currently full.
            - To do this, memory is allocated for double the current capacity.
            - All the elements are copied to the new memory location.
            - And the previous memory is deallocated.

            - Incase the vector is not full, no memory is allocated.
    */
    std::cout << "PushBackTest():" << std::endl;
    PushBackTest();
    std::cout << "\n\n";

    /*
        Summary of DynamicMemoryTest():
            - Memory is allocated whenever new is called.
            - For normal declarations such as,
                int x;
                double y;
                std::string z;
              memory is allocated at compile time.
            - Memory needs to be deallocated manually using delete.
            - Memory allocated using new[] needs to be deallocated using delete[].
    */
    std::cout << "DynamicMemoryTest():" << std::endl;
    DynamicMemoryTest();

    return 0; // Exit the program
}
